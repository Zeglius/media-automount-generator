#!/usr/bin/env bash

#### region Constants, utils and error handling

set -euo pipefail
if [[ ${DEBUG:-0} -eq 1 ]]; then
    export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
    set -x
fi

declare -r MOUNTDIR_PARENT="/media/media-automount"
# Config files should be imported, first ones step over the others:
#   - /etc/media-automount.d
#   - /usr/local/lib/media-automount.d
#   - /usr/lib/media-automount.d
declare -ar CONF_DIRS=(
    /etc/media-automount.d
    /usr/local/lib/media-automount.d
    /usr/lib/media-automount.d
)

log() {
    local loglevel=${loglevel:-info}
    if [[ ${SYSTEMD_SCOPE:-} =~ ^user$|^system$ ]]; then
        echo "$*" | systemd-cat -p "${loglevel}" -t "media-automount-generator"
    else
        echo >&2 "[${loglevel^^}]: $*"
    fi
}

die() {
    loglevel=err log "$@"
    exit 1
}

_on_err() {
    loglevel=err log "Something went wrong"
    exit 0
}

# Search for the first matching file path in one of the config directories.
# Return an empty string if no matching file was found.
#
# Params:
#   $1 - File name
#
# Returns:
#   Path of the file. Empty string if none found
get_filesystem_conf() {
    local file_name=${1:?}
    local result

    for conf_dir in "${CONF_DIRS[@]}"; do
        result=${conf_dir}/${file_name}.conf
        if [[ -r "${result}" ]]; then
            echo "$result"
            return 0
        fi
    done
}

# Check if a device is in fstab.
#
# Params:
#   $1 - Tag of device, see findfs(8)
#
# Status code:
#   0 - The device was found in /etc/fstab
#   1 - The device was not found in /etc/fstab
is_in_fstab() {
    local tag _what _
    tag=${1:?}

    [[ ! -e /etc/fstab ]] && die "/etc/fstab does not exist"

    # Check if _cache_fstab is set, otherwise populate it
    if [[ ! -v _cache_fstab ]] >/dev/null 2>&1; then
        declare -ga _cache_fstab=()
        while read -r _what _ _ _ _ _; do
            [[ $_what =~ ^#.* ]] && continue
            # shellcheck disable=SC2207
            _cache_fstab+=($(findfs "$_what" 2>/dev/null))
        done </etc/fstab
    fi
    # Check if the given tag is listed in _cache_fstab
    if [[ " ${_cache_fstab[*]} " = *"$tag"* ]]; then
        return 0
    fi
    return 1
}

trap '_on_err' ERR

#### endregion

#############################################################

#region Entrypoint

#@entrypoint
# Entrypoint for udev mode.
#
# The script should be placed at '/usr/lib/udev/media-automount-udev'.
OPER_UDEV() {
    exec 2> >(tee -ia /tmp/media-automount-udev.log 2>&1)

    log() {
        echo "$*" >&2
    }
    # Detect whenever we are a background process.
    #
    # If we are not, reexecute this script in a non-blocking fashion,
    # like `systemd-mount --no-block` does.
    if [[ ${MAU_ISBACKGROUND:-0} -ne 1 ]]; then
        log "Reexecuting as background process..."
        MAU_ISBACKGROUND=1 $(realpath -s $0) "$@" & disown
        exit
    fi

    readonly dev=${1:?}

    # Assert dev path matches '/dev/*', just to be sure
    if [[ $dev != /dev/* ]]; then
        log "$dev: Device does not match pattern '/dev/*'. Aborting..."
        exit 1
    fi

    # We are using udev rules to filter out removable/invalid devices.

    # Check if the dev is listed in fstab
    if is_in_fstab "$dev"; then
        log "$dev: Device is already listed in fstab. Exiting..."
        exit 0
    fi

    # Search for a config file matching the partition filesystem
    local config_file
    config_file="$(get_filesystem_conf "${ID_FS_TYPE:?Missing ID_FS_TYPE env var from udev}")"

    # Handle config_file readability
    case $(realpath "$config_file") in
    "")
        log "$dev: Config for filesystem $ID_FS_TYPE was not found"
        exit 0;;

    /dev/null)
        log "$dev: Masking conf file $conf_file pointing at /dev/null. Skipping..."
        exit 0;;
    esac
    log "$dev: Config file found at $conf_file"

    # Load options from config file
    local _line FSOPTIONS="" FSTYPE=""
    while read -r _line; do
        [[ $_line =~ ^FSOPTIONS=(.*)$ ]] && FSOPTIONS="${BASH_REMATCH[1]%%[[:space:]]*}"
        [[ $_line =~ ^FSTYPE=(.*)$ ]] && FSTYPE="${BASH_REMATCH[1]%%[[:space:]]*}"
    done <"$conf_file" && unset -v _line

    # Run systemd-mount with the options given
    systemd-mount \
        --no-block \
        ${FSOPTIONS:+-o "$FSOPTIONS"} \
        ${FSTYPE:+-t $FSTYPE} \
        "$dev" MOUNTDIR_PARENT/"${ID_FS_UUID:?Missing ID_FS_UUID env var from udev}" >(log "$dev: $(</dev/stdin)") 2>&1
}

#@entrypoint
# Entrypoint for systemd-generator mode
OPER_GENERATOR() {

    # UNITS_DIR is the first parameter passed, despicting the directory
    # where the units will be generated.
    declare -r UNITS_DIR=${1:?}

    # Dont run if we are in a container or a virtual machine
    if [[ -n ${SYSTEMD_VIRTUALIZATION:-} ]]; then
        log "System is running in ${SYSTEMD_VIRTUALIZATION}, skipping..."
        exit 0
    fi

    # Check if generator is wanted to be enabled.
    # WARNING: This only should be used by the system admin and not the vendor.
    # WARNING: This file SHOULD NOT contain any configuration.
    # It is meant to be a global /dev/null symlink.
    global_conf_file=$(get_filesystem_conf _all)

    # Iterate in a list of partitions
    for dev in $(systemd-mount --list --no-pager --no-legend --full | cut -d' ' -f1); do
        # Check if the device is already set for mounting, and if is, skip it
        if is_in_fstab "$dev"; then
            log "$dev: device is already mounted. Skipping..."
            continue
        fi

        # Ensure we are not dealing with LUKS or LVM devices
        if [[ $dev == /dev/mapper/* || $dev =~ /dev/dm-[[:digit:]] ]]; then
            log "$dev: device might be LUKS or LVM. Skipping..."
            continue
        fi

        # Check if is removable, and if so, skip it
        parent_dev=$(lsblk -n --inverse --output=NAME --filter='TYPE == "disk"' "$dev" | tail -1)
        if [[ $(</sys/block/"$parent_dev"/removable) -eq 1 ]]; then
            log "$dev: device is removable. Skipping..."
            continue
        fi

        # Check if we have a config for the partition type
        fstype=$(lsblk -n --output FSTYPE "$dev")
        [[ -z $fstype ]] && continue
        conf_file=${global_conf_file:-$(get_filesystem_conf "$fstype")}
        if [[ -z $conf_file ]]; then
            log "$dev: Config for filesystem $fstype was not found"
            continue
        elif [[ $(realpath "$conf_file") == /dev/null ]]; then # When the file is a symlink pointing at /dev/null
            log "$dev: Masking conf file $conf_file pointing at /dev/null. Skipping..."
            continue
        fi

        # Load the config file
        unset -v FSOPTIONS FSTYPE
        # shellcheck disable=SC1090
        eval "$(
            source "$conf_file" >/dev/null
            echo "${FSOPTIONS@A}"
            # shellcheck disable=SC2153
            echo "${FSTYPE@A}"
        )"

        # Write the unit file
        dev_uuid="$(lsblk -n --output UUID "$dev")"
        What="UUID=$dev_uuid"
        Where=$(realpath -m ${MOUNTDIR_PARENT%%/}/"$dev_uuid") # Get device UUID
        Type=${FSTYPE:-$fstype}
        unit_file_path="$UNITS_DIR"/"$(systemd-escape -p --suffix=mount "$Where")"
        cat <<EOF >"$unit_file_path"
# Unit generated by ${0}
[Unit]
SourcePath=${conf_file}
Before=local-fs.target
After=-.mount
After=boot.mount

[Mount]
What=${What:?}
Where=${Where:?}
Type=${Type:?}
${FSOPTIONS:+Options=${FSOPTIONS}}
EOF
        if [[ ! -s $unit_file_path ]]; then
            log "$dev: Generated mount unit file at $unit_file_path is empty. Skipping..."
            continue
        fi
        log "$dev: Generated mount unit file at $unit_file_path"
        mkdir -p "${UNITS_DIR}"/local-fs.target.wants
        ln -sr "$unit_file_path" "${UNITS_DIR}"/local-fs.target.wants/
        log "$dev: Symlinked $unit_file_path to ${UNITS_DIR}/local-fs.target.wants/$(basename "$unit_file_path")"
    done

    log "Unit files were generated. Stopping process..."

}

#endregion Entrypoint

#############################################################

# Detect which entrypoint should be used for the script
case "${0}" in
*media-automount-udev)
    OPER_UDEV "$@"
    exit;;
*)
    # Fallback to generator mode by default
    OPER_GENERATOR "$@"
    exit;;
esac
