#!/usr/bin/env bash

#### region Constants, utils and error handling

set -euo pipefail
if [[ ${DEBUG:-0} -eq 1 ]]; then
    export PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
    set -x
fi

declare -r UNITS_DIR=${1:?}
declare -r MOUNTDIR_PARENT="/media/media-automount"
# Config files should be imported, first ones step over the others:
#   - /etc/media-automount.d
#   - /usr/local/lib/media-automount.d
#   - /usr/lib/media-automount.d
declare -ar CONF_DIRS=(
    /etc/media-automount.d
    /usr/local/lib/media-automount.d
    /usr/lib/media-automount.d
)

log() {
    local loglevel=${loglevel:-info}
    if [[ ${SYSTEMD_SCOPE:-} =~ ^user$|^system$ ]]; then
        echo "$*" | systemd-cat -p "${loglevel}" -t "media-automount-generator"
    else
        echo >&2 "[${loglevel^^}]: $*"
    fi
}

die() {
    loglevel=err log "$@"
    exit 1
}

_on_err() {
    loglevel=err log "Something went wrong"
    exit 0
}

# Search for the first matching file path in one of the config directories.
# Return an empty string if no matching file was found.
#
# Params:
#   $1 - File name
#
# Returns:
#   Path of the file. Empty string if none found
get_filesystem_conf() {
    local file_name=${1:?}
    local result

    for conf_dir in "${CONF_DIRS[@]}"; do
        result=${conf_dir}/${file_name}.conf
        if [[ -r "${result}" ]]; then
            echo "$result"
            return 0
        fi
    done
}

# Check if a device is in fstab.
#
# Params:
#   $1 - Tag of device, see findfs(8)
#
# Status code:
#   0 - The device was found in /etc/fstab
#   1 - The device was not found in /etc/fstab
is_in_fstab() {
    local tag _what _
    tag=${1:?}

    [[ ! -e /etc/fstab ]] && die "/etc/fstab does not exist"

    # Check if _cache_fstab is set, otherwise populate it
    if [[ ! -v _cache_fstab ]] >/dev/null 2>&1; then
        declare -ga _cache_fstab=()
        while read -r _what _ _ _ _ _; do
            [[ $_what =~ ^#.* ]] && continue
            # shellcheck disable=SC2207
            _cache_fstab+=($(findfs "$_what" 2>/dev/null))
        done </etc/fstab
    fi
    # Check if the given tag is listed in _cache_fstab
    if [[ " ${_cache_fstab[*]} " = *"$tag"* ]]; then
        return 0
    fi
    return 1
}

trap '_on_err' ERR

#### endregion

#############################################################

# Dont run if we are in a container or a virtual machine
if [[ -n ${SYSTEMD_VIRTUALIZATION:-} ]]; then
    log "System is running in ${SYSTEMD_VIRTUALIZATION}, skipping..."
    exit 0
fi

# Check if generator is wanted to be enabled.
# WARNING: This only should be used by the system admin and not the vendor.
# WARNING: This file SHOULD NOT contain any configuration.
# It is meant to be a global /dev/null symlink.
global_conf_file=$(get_filesystem_conf _all)

# Iterate in a list of partitions
for dev in $(systemd-mount --list --no-pager --no-legend --full | cut -d' ' -f1); do
    # Check if the device is already set for mounting, and if is, skip it
    if is_in_fstab "$dev"; then
        log "$dev: device is already mounted. Skipping..."
        continue
    fi

    # Ensure we are not dealing with LUKS or LVM devices
    if [[ $dev == /dev/mapper/* ]]; then
        log "$dev: device might be LUKS or LVM. Skipping..."
        continue
    fi

    # Check if is removable, and if so, skip it
    parent_dev=$(lsblk -n --inverse --output=NAME --filter='TYPE == "disk"' "$dev" | tail -1)
    if [[ $(</sys/block/"$parent_dev"/removable) -eq 1 ]]; then
        log "$dev: device is removable. Skipping..."
        continue
    fi

    # Check if we have a config for the partition type
    fstype=$(lsblk -n --output FSTYPE "$dev")
    [[ -z $fstype ]] && continue
    conf_file=${global_conf_file:-$(get_filesystem_conf "$fstype")}
    if [[ -z $conf_file ]]; then
        log "$dev: Config for filesystem $fstype was not found"
        continue
    elif [[ $(realpath "$conf_file") == /dev/null ]]; then # When the file is a symlink pointing at /dev/null
        log "$dev: Masking conf file $conf_file pointing at /dev/null. Skipping..."
        continue
    fi

    # Load the config file
    unset -v FSOPTIONS FSTYPE
    # shellcheck disable=SC1090
    eval "$(
        source "$conf_file" >/dev/null
        echo "${FSOPTIONS@A}"
        # shellcheck disable=SC2153
        echo "${FSTYPE@A}"
    )"

    # Write the unit file
    dev_uuid="$(lsblk -n --output UUID "$dev")"
    What="UUID=$dev_uuid"
    Where=$(realpath -m ${MOUNTDIR_PARENT%%/}/"$dev_uuid") # Get device UUID
    Type=${FSTYPE:-$fstype}
    unit_file_path="$UNITS_DIR"/"$(systemd-escape -p --suffix=mount "$Where")"
    cat <<EOF >"$unit_file_path"
# Unit generated by ${0}
[Unit]
SourcePath=${conf_file}
Before=local-fs.target
After=-.mount
After=boot.mount

[Mount]
What=${What:?}
Where=${Where:?}
Type=${Type:?}
${FSOPTIONS:+Options=${FSOPTIONS}}
EOF
    if [[ ! -s $unit_file_path ]]; then
        log "$dev: Generated mount unit file at $unit_file_path is empty. Skipping..."
        continue
    fi
    log "$dev: Generated mount unit file at $unit_file_path"
    mkdir -p "${UNITS_DIR}"/local-fs.target.wants
    ln -sr "$unit_file_path" "${UNITS_DIR}"/local-fs.target.wants/
    log "$dev: Symlinked $unit_file_path to ${UNITS_DIR}/local-fs.target.wants/$(basename "$unit_file_path")"
done

log "Unit files were generated. Stopping process..."
